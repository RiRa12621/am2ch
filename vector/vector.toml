[sources.webhook]
type = "http_server"
address = "0.0.0.0:8888"
headers = [ "User-Agent" ]
query_parameters = [ "application" ]
path = "/"
strict_path = true
path_key = "path"
method = "POST"
encoding = "json"

[transforms.webhook_transform]
inputs = [ "webhook" ]
type = "remap"
source = """
. = unnest!(.alerts)
. = map_values(.) -> |v| {
  value = v.alerts
  del(v.alerts)
  value.endsAt = parse_timestamp!(value.endsAt, format: "%Y-%m-%dT%H:%M:%S%.fZ")
  value.endsAt = to_unix_timestamp(value.endsAt, "milliseconds")
  value.startsAt = parse_timestamp!(value.startsAt, format: "%Y-%m-%dT%H:%M:%S%.fZ")
  value.startsAt = to_unix_timestamp(value.startsAt, "milliseconds")
  value.user_agent = del(value."User-Agent")
  value.status.state = del(value.status)

  value.labelskv = encode_key_value!(value.labels)

  labelsmap = value.labels
  labelsmap_encoded = encode_json(labelsmap)
  value.md5 = md5(labelsmap_encoded)

  value.source = "webhook"
  flatten(value)
}
"""

[transforms.webhook_transform2]
inputs = [ "webhook_transform" ]
type = "remap"
source = """
.labelsmap = parse_key_value!(.labelskv)
"""

[sources.alerts]
type = "http_client"
endpoint = "http://alertmanager:9093/api/v2/alerts"
method = "GET"
decoding.codec = "json"
scrape_interval_secs = 60

  [sources.alerts.headers]
  Accept = [ "application/json", "text/plain" ]

[transforms.vrl]
inputs = [ "alerts" ]
type = "remap"
source = """
# to split the multiline event to small events
"""

[transforms.vrl2]
inputs = [ "vrl" ]
type = "remap"
source = """
.timestamp = parse_timestamp!(.timestamp, format: "%Y-%m-%dT%H:%M:%S%.fZ")
.timestamp = to_unix_timestamp(.timestamp, "milliseconds")
.endsAt = to_timestamp!(.endsAt, unit: "milliseconds")
.endsAt = to_unix_timestamp(.endsAt, "milliseconds")
.updatedAt = to_timestamp!(.updatedAt, unit: "milliseconds")
.updatedAt = to_unix_timestamp(.updatedAt, "milliseconds")
.startsAt = to_timestamp!(.startsAt, unit: "milliseconds")
.startsAt = to_unix_timestamp(.startsAt, "milliseconds")

.rec = del(.receivers)
.receivers = []
for_each(array!(.rec)) -> |_index, r| {
    .rid = get!(.rec, [to_int(_index)])
    .receivers = push(.receivers, .rid.name )
}
del(.rec)
del(.rid)

.labelskv = encode_key_value!(.labels)
labelsmap = .labels
. = flatten(.)
labelsmap_encoded = encode_json(labelsmap)
.md5 = md5(labelsmap_encoded)

if is_empty(array!(."status.silencedBy")) {
  del(.status.silencedBy)
  ."status.silencedBy" = ""
} else {
  . = unnest!(."status.silencedBy")
}

"""

[sinks.stdout]
type = "console"
inputs = [ "webhook_transform2"]
target = "stdout"
  [sinks.stdout.encoding]
  codec = "text"

[sinks.clickhouse]
inputs = ["webhook_transform2", "vrl2"]
type = "clickhouse"
database = "r0"
endpoint = "http://clickhouse-0.localhost:8123"
table = "alerts"
compression = "gzip"
tls.verify_hostname = false
auth.user = "demouser"
auth.password = "239QV8JkGmF9AZM"
auth.strategy = "basic"
batch.timeout_secs = 10
